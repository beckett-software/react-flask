{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcab React Flask (RF)","text":""},{"location":"#build-type-safe-python-and-typescript-applications","title":"Build type safe Python and TypeScript applications","text":"<p>Welcome to RF, a strongly-linked Flask and React application template.</p> <p>RF combines a Flask server, with a React TypeScript UI into a comprehensive full-stack framework for building modern web applications.</p> <p>RF features a sophisticated types manager that automatically synchronizes Python Type hints and TypeScript interfaces. This means that as you make changes to your API code in the server, RF diligently keeps the API Client up to date.</p>"},{"location":"#built-on-popular-tools","title":"Built on popular tools","text":"<p>We use cutting edge Python tools including:</p> <ul> <li>Pydantic 2.0</li> <li>Flask 2.3</li> </ul> <p>And our TypeScript is modern too:</p> <ul> <li>Node 18.17.0</li> <li>React 18</li> <li>TypeScript 5.1</li> </ul> <p>Both TypeScript and Python hold their positions as two of the most widely used programming languages globally. As a result, they are frequently combined in various projects.</p> <p>However, setting up a smooth and efficient development environment that integrates these languages can be a cumbersome and time-consuming process, often leading to a subpar developer experience. Thankfully, RF steps in to solve this challenge by through it's sophisticated types manager.</p>"},{"location":"#type-safe-productivity-boost","title":"Type-safe productivity boost","text":"<p>RF provides:</p> <ul> <li>A types manager which keeps the API interface type-safe.</li> <li>React: A collection of type-safe API hooks for querying the HTTP API.</li> <li>React: No single page app, so bundled JS for the client loads faster.</li> <li>Flask: A manager for generating new React pages without any manual effort.</li> <li>Flask: View-based routing to reduce the bundle size of JS on page loads.</li> </ul> <p>Wanna learn more? Start with the install step to get started.</p>"},{"location":"install/","title":"\ud83c\udfd7\ufe0f Install","text":""},{"location":"install/#early-days","title":"Early days","text":"<p>Before this becomes a fully fledged package, this project exists as a template you can fork and build from.</p> <p>Once forked, all you have to do is run this command:</p> <pre><code>make build\n</code></pre> <p>Then finally, you can either run both the Flask and Typescript server in one terminal with:</p> <pre><code>make dev\n</code></pre> <p>Or run them independently with:</p> <pre><code>make serve\nmake web\n</code></pre> <p>This will start up the development server.</p> <p>Now you can start the tutorial to build your first RF page.</p>"},{"location":"todo/","title":"\ud83d\udccb TODO","text":"<p>There is a bunch of stuff I want to add to RF, feel free to contribute!</p> <ul> <li>Add a <code>meta</code> class to the <code>PageProps</code> so things like the html <code>&lt;title&gt;</code> tag can be updated, etc.</li> <li>Put the JS into a CDN so there is less boilerplate.</li> <li>Abstract the types stuff so that it can be a generic library.</li> <li>Make the app more of a \"package\" so it is easier to install.</li> <li>Move all the <code>make</code> commands to a <code>RF</code> command line tool.</li> </ul>"},{"location":"tutorial/","title":"\ud83d\udcdd Tutorial","text":""},{"location":"tutorial/#early-days","title":"Early days","text":"<p>Before this becomes a fully fledged package, this project exists as a template you can fork and build from. My advice for getting started is to build ontop of what already exists, and use the existing routes until you understand it, then you can delete it!</p> <p>Note</p> <p>This example will work you through making a simple Bookshop app and API.</p>"},{"location":"tutorial/#add-your-first-view","title":"Add your first view","text":"<p>In <code>src.views</code> add a new file called <code>books.py</code> and add the following code:</p> src/views/books.py<pre><code>from src.app import app\nfrom src.rf.blueprint import RFBlueprint\nrf = RFBlueprint(\"books\", __name__, url_prefix=\"/books\")\n@rf.route(\"/\")\ndef home():\nreturn dict(title=\"My books\")\napp.register_blueprint(rf)\n</code></pre> <p>Then in <code>src.views.__init__</code> we just need to do a small update as seen on line 2:</p> src/views/__init__.py<pre><code>from src.views import people, index  # noqa\nfrom .books import *\n</code></pre> <p>This small import will let the RF APP know to include your views file in the application.</p> <p>At this point you can now visit http://localhost:9000/books/ to see a simple API response.</p>"},{"location":"tutorial/#turn-it-into-a-react-page","title":"Turn it into a React page","text":"<p>Let's make this simple API response become something far more interesting - a whole react page!</p> <p>We only need to make a few changes:</p> src/views/books.py<pre><code>from src.app import app\nfrom src.rf.blueprint import RFBlueprint\nfrom src.rf.types import PageProps\nrf = RFBlueprint(\"books\", __name__, url_prefix=\"/books\")\nclass HomePageProps(PageProps):\ntitle: str\n@rf.route(\"/\")\n@rf.page()\ndef home() -&gt; HomePageProps:\nreturn HomePageProps(title=\"My books\")\napp.register_blueprint(rf)\n</code></pre> <p>Quite a few interesting things should happen when you save the file - you'll see two brand new files appear in the <code>src/js/templates</code> directory. I know you want to inspect them and see what has changed, but for now let us go over the changes in the <code>books.py</code> file first:</p> <pre><code>from src.rf.types import PageProps\n</code></pre> <p>The <code>PageProps</code> baseclass should be used for all React pages.</p> <pre><code>class HomePageProps(PageProps):\ntitle: str\n</code></pre> <p>This is the response type of your React page, and will be transformed into an equivalent Typescript interface. You can inspect the sibling interface now in <code>src/js/template/books/home.type.ts</code>:</p> <pre><code>export default interface PageProps {\n\"title\": string\n}\n</code></pre> <p>Notice how the name of the interface has changed? This is because each React page in RF only has one set of initial props for a page load, and this naming convention helps to pick it out.</p> <pre><code>@rf.page()\ndef home() -&gt; HomePageProps:\nreturn HomePageProps(title=\"My books\")\n</code></pre> <p>Here you will see we have updated the Flask view function with a return type, our <code>HomePageProps</code>, that we wrote earlier.</p> <p>We have also updated the return line to return an instance of that class.</p> <p>The one line of code that makes this all magically generate the files is <code>rf.page()</code>. This decorator inspects all the associated pages when the server is in development mode, and if it can't find a related TypeScript file for it, it will generate it for you. </p> <p>Here are the files it has generated for us:</p> <ul> <li><code>src/js/template/books/home.tsx</code></li> <li><code>src/js/template/books.home.type.ts</code></li> </ul> <p>Notice how RF has intelligently figured out the directory and the file name from the name of the python file and the view function.</p> <p>Note</p> <p>Sometimes when a new file is generated you need to run <code>make web</code> again for the page to load - this is only a problem the first time and we're working to fix that bug.</p> <p>If you refresh your browser at http://localhost:9000/books/ you should see a react page with the default template information from <code>src/js/template/books/home.tsx</code>.</p>"},{"location":"tutorial/#add-an-api-view","title":"Add an API view","text":"<p>React is most useful when we can make concurrent API requests to our application server and return content.</p> <p>RF manages API views that we can be used in our React pages. Let's make one now.</p> <p>Add this just the <code>home</code> view function:</p> <p>src/views/books.py<pre><code>from src.rf.types import APIResponse\nclass BookResponse(APIResponse):\nname: str\nauthor: str\n@rf.api_get(\"/details\")\ndef details() -&gt; BookResponse:\nreturn BookResponse(name=\"Gideon the Ninth\", author=\"Tamsyn Muir.\")\n</code></pre> Hit save and you should see some files change again (that happens a lot with RF). Let's go over this change quickly.</p> <pre><code>from src.rf.types import APIResponse\n</code></pre> <p>All of RF's API Views must return a subclass of <code>APIResponse</code>. There are a few generic helpers in <code>src.rf.types</code> too if you want to return common responses like <code>Forbidden</code> or <code>NotFound</code>.</p> <pre><code>class BookResponse(APIResponse):\nname: str\nauthor: str\n</code></pre> <p>The <code>BookResponse</code> is the response class we're using for our API. You'll see in <code>src/js/api/types.ts</code> that this gets transformed into a TypeScript interface:</p> src/js/api/types.ts<pre><code>export interface BooksDetailsResponse {\n\"status_code\": number\n\"name\": string\n\"author\": string\n}\n</code></pre> <p>This all happens because of the decorator function <code>rf.api_get</code>:</p> <pre><code>@rf.api_get(\"/details\")\ndef details() -&gt; BookResponse:\nreturn BookResponse(name=\"Gideon the Ninth\", author=\"Tamsyn Muir.\")\n</code></pre> <p>Similar to <code>rf.api</code> - this decorator will inspect the view functions when in development mode, and generate appropriate TypeScript interfaces for you.</p> <p>This interface is available in our TypeScript code now, but we don't acutally need to plug it into our APIClient, because RF has done that already for us! </p> <p>Have a look further down the <code>types.ts</code> file:</p> src/js/api/types.ts<pre><code>export interface GET_MAP {\n// react_flask/src/views/books.py\n\"books.details\": {request: undefined, response: BooksDetailsResponse}\n// react_flask/src/views/people.py\n\"people.get_people\": {request: undefined, response: PeopleGetPeopleResponse}\n}\n</code></pre> <p>The <code>GET_MAP</code> has updated to include the request (currently none) and response types for this API endpoint. So how do we use it?</p>"},{"location":"tutorial/#using-the-api-client","title":"Using the API Client","text":"<p>Let's write some typescript shall we?</p> <p>Open up <code>src/js/template/books/home.tsx</code> and make these changes:</p> src/js/template/books/home.tsx<pre><code>import React from 'react'\nimport PageProps from './home.type'\nimport {Container, Row} from 'react-bootstrap'\nimport { useGet } from '~/api/query'\nconst Page: React.FunctionComponent&lt;PageProps&gt; = props =&gt; {\nconst {data} = useGet(\"books.details\")\nreturn (\n&lt;Container&gt;\n&lt;Row className=\"mb-4 border-bottom\"&gt;\n&lt;h1&gt;Hello, React!&lt;/h1&gt;\n&lt;p&gt;\nHere are your props:{' '}\n&lt;code&gt;\n{Object.keys(props).map(p =&gt; (\n&lt;p&gt;\n{p} : {props[p]}\n&lt;/p&gt;\n))}\n&lt;/code&gt;\n&lt;/p&gt;\n&lt;p&gt;\nBook name: {data.name}\n&lt;/p&gt;\n&lt;p&gt;\nBook author: {data.author}\n&lt;/p&gt;\n&lt;/Row&gt;\n&lt;/Container&gt;\n)\n}\nexport default Page\n</code></pre> <p>Let's go over these changes so they make sense.</p> <pre><code>import { useGet } from '~/api/query'\n</code></pre> <p><code>useGet</code> is a React Hook that provides access to all the registered API views in our RF application.</p> <p>It uses the <code>GET_MAP</code> to make sure the request and responses remain consistent.</p> <pre><code>const {data} = useGet(\"books.details\")\n</code></pre> <p>We do not need to provide any inputs to the <code>useGet</code> function except for the API view we want to call - in this case it will always be the <code>file_name.view_function</code> pattern. In fact, if you typed the example out letter by letter you would've noticed that it provided autocomplete!</p> <p>Because RF's React pages use React suspense - it gracefully handles the loading state for you. This means that the page will not render until the API call has returned a response.</p> <pre><code>&lt;p&gt;\nBook name: {data.name}\n&lt;/p&gt;\n&lt;p&gt;\nBook author: {data.author}\n&lt;/p&gt;\n</code></pre> <p>Because we don't need to worry about the loading state, we can safely apply the values from the API call into our React page.</p>"},{"location":"tutorial/#apis-with-input-parameters","title":"APIs with input parameters","text":"<p>Let's grow our API functionality even more by making it require an input value. We'll update the API View first:</p> src/views/books.py<pre><code>@rf.api_get(\"/details\")\ndef details(name: str) -&gt; BookResponse:\nreturn BookResponse(name=name, author=\"Tamsyn Muir.\")\n</code></pre> <p>The only thing we've changed here is we've added an input parameter <code>name</code>, which is a <code>str</code>, and then returned it in our API Response. This is just a simple demonstrative example, but you could imagine making database queries or doing some complex maths here - it's just Python after all!</p> <p>When you save this, you'll notice a new TypeScript interface will be generated in <code>src/js/api/types.ts</code>:</p> src/js/api/types.ts<pre><code>export interface BooksDetailsRequest {\n\"name\": string\n}\n</code></pre> <p>This new request interface will be mapped to the <code>GET_MAP</code> in the same file:</p> src/js/api/types.ts<pre><code>export interface GET_MAP {\n// react_flask/src/views/books.py\n\"books.details\": {request: BooksDetailsRequest, response: BooksDetailsResponse}\n// react_flask/src/views/people.py\n\"people.get_people\": {request: undefined, response: PeopleGetPeopleResponse}\n}\n</code></pre> <p>In fact, if you try and refresh the browser at http://localhost:9000/books/ you'll see this take affect immediately - the page will crash! This is because the <code>name</code> value in the request is a required parameter.</p> <p>Let's update our React app so we can send input data to our API Client.</p> src/js/template/books/home.tsx<pre><code>import React from 'react'\nimport PageProps from './home.type'\nimport {Container, Row} from 'react-bootstrap'\nimport { useGet } from '~/api/query'\nconst Page: React.FunctionComponent&lt;PageProps&gt; = props =&gt; {\nconst {data} = useGet(\"books.details\", {name: \"My book\"})\n...\n</code></pre> <p>For the sake of brevity we've removed a bunch of this code in the tutorial. The only change needed is to pass an object with the required parameters to the API and then the page should load fine. You'll notice as you type of the object it will give you hints as to the expected input parameters.</p> <p>Magic, eh?</p>"},{"location":"tutorial/#api-post-requests","title":"API Post requests","text":"<p>Now that we've built an API that accepts data and returns it, let's build something more functional. How about an HTTP POST API View?</p> <p>What's the difference between a POST view and a GET view in RF?</p> <ul> <li>HTTP GET views format the input parameters as query parameters and are great for loading content quickly.</li> <li>HTTP POST views receive their inputs as JSON in the HTTP Body and accept much more content.</li> <li>HTTP POST views are preferred when we want to make state changes to our application.</li> </ul> <p>First things first, let's add a new View to our API:</p> src/views/books.py<pre><code>class BookUpdateResponse(APIResponse):\nname: str\nauthor: str\n@rf.api_post(\"/add\")\ndef add(name: str, author: str) -&gt; BookUpdateResponse:\n# Imagine database persistence happens here\nreturn BookUpdateResponse(name=name, author=author)\n</code></pre> <p>This should all be looking very familiar now. The one small difference from the previous API is we are using <code>rf.api_post</code> instead of <code>rf.api_get</code>.</p> <p>Just like before, this will have generated two new interfaces for us:</p> src/js/api/types.ts<pre><code>export interface BooksAddRequest {\n\"name\": string\n\"author\": string\n}\nexport interface BooksAddResponse {\n\"status_code\": number\n\"name\": string\n\"author\": string\n}\n</code></pre> <p>You will also see the <code>POST_MAP</code> will have been updated:</p> src/js/api/types.ts<pre><code>export interface POST_MAP {\n// react_flask/src/views/books.py\n\"books.add\": {request: BooksAddRequest, response: BooksAddResponse}\n// react_flask/src/views/people.py\n\"people.post_example\": {request: PeoplePostExampleRequest, response: PeoplePostExampleResponse}\n}\n</code></pre> <p>Similar to the <code>GET_MAP</code>, the <code>POST_MAP</code> allows us to manage the API Client nicely.</p> <p>Let's add a form that uses this API to our <code>home.tsx</code> file:</p> src/js/template/books/home.tsx<pre><code>import React, {useState} from 'react'\nimport PageProps from './home.type'\nimport {Container, Row} from 'react-bootstrap'\nimport {useGet, usePost} from '~/api/query'\nconst Page: React.FunctionComponent&lt;PageProps&gt; = props =&gt; {\nconst {data} = useGet('books.details', {name: 'My book'})\nconst addBook = usePost('books.add')\ninterface Book {\nname: string\nauthor: string\n}\nconst [allBooks, setAllBooks] = useState&lt;Book[]&gt;([{name: 'First book', author: 'No one'}])\nconst [formName, setName] = useState&lt;string&gt;('')\nconst [formAuthor, setAuthor] = useState&lt;string&gt;('')\nreturn (\n&lt;Container&gt;\n&lt;Row className=\"mb-4 border-bottom\"&gt;\n&lt;h1&gt;Hello, React!&lt;/h1&gt;\n&lt;p&gt;\nHere are your props:{' '}\n&lt;code&gt;\n{Object.keys(props).map(p =&gt; (\n&lt;p&gt;\n{p} : {props[p]}\n&lt;/p&gt;\n))}\n&lt;/code&gt;\n&lt;/p&gt;\n&lt;p&gt;Book name: {data.name}&lt;/p&gt;\n&lt;p&gt;Book author: {data.author}&lt;/p&gt;\n&lt;/Row&gt;\n&lt;Row&gt;\n&lt;h1&gt;Add book&lt;/h1&gt;\n&lt;p&gt;\nName: &lt;input value={formName} onChange={v =&gt; setName(v.target.value)} /&gt;\n&lt;/p&gt;\n&lt;p&gt;\nAuthor: &lt;input value={formAuthor} onChange={v =&gt; setAuthor(v.target.value)} /&gt;\n&lt;/p&gt;\n&lt;button\nonClick={() =&gt;\naddBook.mutate(\n{name: formName, author: formAuthor},\n{\nonSuccess: response =&gt; {\nallBooks?.push({name: response.name, author: response.author})\nsetAllBooks(Array.from(allBooks))\n},\nonError: () =&gt; console.log(addBook.error),\n},\n)\n}\n&gt;\nAdd\n&lt;/button&gt;\n&lt;/Row&gt;\n&lt;Row&gt;\n&lt;ul&gt;\n{allBooks.map(book =&gt; &lt;li&gt;{book.name} by {book.author}&lt;/li&gt;)}\n&lt;/ul&gt;\n&lt;/Row&gt;\n&lt;/Container&gt;\n)\n}\nexport default Page\n</code></pre> <p>I appreciate that quite a lot of lines have been added here. This may look a bit intimdating if you're not used to React but don't worry it'll all make sense.</p> <p>Let's break down each section bit by bit.</p> <pre><code>const addBook = usePost('books.add')\n</code></pre> <p>The <code>usePost</code> hook behaves very differently to the <code>useGet</code> hook. This is because we often want to trigger to hook after a state change or button press.</p> <p>Under the hood, the <code>usePost</code> hook provides a TanStack Query hook for managing the API request.</p> <pre><code>interface Book {\nname: string\nauthor: string\n}\nconst [allBooks, setAllBooks] = useState&lt;Book[]&gt;([{name: 'First book', author: 'No one'}])\nconst [formName, setName] = useState&lt;string&gt;('')\nconst [formAuthor, setAuthor] = useState&lt;string&gt;('')\n</code></pre> <p>This code sets ups some state using React's state library. We'll use it for the form and the list on the page.</p> <pre><code>&lt;button\nonClick={() =&gt;\naddBook.mutate(\n{name: formName, author: formAuthor},\n{\nonSuccess: response =&gt; {\nallBooks?.push({name: response.name, author: response.author})\nsetAllBooks(Array.from(allBooks))\n},\nonError: () =&gt; console.log(addBook.error),\n},\n)\n}\n&gt;\nAdd\n&lt;/button&gt;\n</code></pre> <p>The <code>button</code> logic is the most interesting part of this change - it is where we trigger our POST API request!</p> <p>The mutate method is the standard TanStack one, but RF forces the input data to match the <code>BookAddRequest</code> interface it generated earlier.</p> <p>The rest of this code follows the standard <code>useMutation</code> side effects from Tanstack which you can read about here.</p> <p>When you read the page at http://localhost:9000/books/ you will notice the new form is available. If you enter some content in it and hit \"Add\" - the UI updates, but if you open your network tab in the developer console (right click -&gt; Inspect -&gt; Network) you will see API requests being issued to the Flask server when you click the button.</p> <p>Want to see how the input validation works in real time? Set the input fields to be empty and hit enter, and you will see some API errors in the console tab.</p>"},{"location":"tutorial/#refreshing-requests","title":"Refreshing requests","text":"<p>If you want to refresh a request you can do this using the <code>useInvalidate</code> hook:</p> <pre><code>const invalidate = useInvalidate()\n&lt;button onClick={\n() =&gt; invalidate('books.details', {name: 'New book'})\n}&gt;Update book&lt;/button&gt;\n</code></pre>"}]}