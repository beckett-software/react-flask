{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcab Beckett Framework","text":"<p>The Framework for Building strictly-typed Python and React TypeScript Websites</p> <p></p> <p>Welcome to Beckett, a strictly-typed Flask and React TypeScript application template.</p> <p>Beckett combines a Flask server, with a robust React TypeScript UI, to provide a comprehensive full stack framework.</p> <p>Beckett features a sophisticated types manager that automatically synchronizes Python Type hints and TypeScript interfaces. This means that as you make changes to your code, Beckett diligently keeps the API interface in perfect harmony.</p> <p>While Beckett is strongly opinionated, favoring specific design choices, it significantly enhances productivity by providing a cohesive development experience and reducing the time spent on manual synchronization.</p> <p></p>"},{"location":"#built-on-popular-tools","title":"Built on popular tools","text":"<p>Both TypeScript and Python hold their positions as two of the most widely used programming languages globally. As a result, they are frequently combined in various projects.</p> <p>However, setting up a smooth and efficient development environment that harmoniously integrates these languages can be a cumbersome and time-consuming process, often leading to a subpar developer experience. Thankfully, Beckett steps in to solve this challenge by tightly coupling TypeScript and Python into one cohesive framework.</p> <p>Wanna learn more? Start with the features to learn what Beckett brings to the table.</p>"},{"location":"configuration/","title":"\ud83d\udd27 Configuration","text":"<p>Beckett is heavily convention-based, yet you can configure quite a bit of it based on what your project set up needs.</p>"},{"location":"configuration/#settings","title":"Settings","text":"<p>All settings should be set as environment variables.</p>"},{"location":"configuration/#environment","title":"<code>ENVIRONMENT</code>","text":"<p>Default: <code>development</code></p> <p>When this variable is set to <code>development</code> in order to enable the Beckett hot-reloader and auto generation features.</p>"},{"location":"configuration/#beckett_metafile_path","title":"<code>BECKETT_METAFILE_PATH</code>","text":"<p>Defaut: <code>{pwd}/metafile.json</code></p> <p>The file tracks the manifest of React pages registered in the app, and enables hot-reloading in development. In production is provides a link between the Flask view function and the React page (because it will be generated with a hash that the Flask view function doesn't know about).</p>"},{"location":"configuration/#beckett_react_page_template","title":"<code>BECKETT_REACT_PAGE_TEMPLATE</code>","text":"<p>Default: <code>{pwd}/template/beckett_page.template</code></p> <p>This is the template used when generating new React pages.</p>"},{"location":"features/","title":"\ud83d\udcc4 Features","text":""},{"location":"features/#strongly-linked-types","title":"Strongly-linked types","text":"<p>When we built Beckett we decided that if we're going to bundle the languages together, why not link them strongly and find extra benefits?</p> <p>The first major feature we built was strongly-linked types.</p> <p>Beckett takes your Python Typehints and auto-generates TypeScript interfaces to maintain type integrity across both languages. It does this automatically for any API endpoints in the Flask web server using the Beckett decorators.</p> src/views/people.py<pre><code>from src.app import app\nfrom src.beckett.blueprint import BeckettBlueprint\nfrom src.beckett.types import APIResponse\nblueprint = BeckettBlueprint(\"people\", __name__, url_prefix=\"/people\")\nclass GetPeopleResponse(APIResponse):\nname: str\n@blueprint.api_get(\"/get\")\ndef get_people() -&gt; GetPeopleResponse:\n\"\"\"\n    This is an example API GET route.\n    \"\"\"\nreturn GetPeopleResponse(name=\"Paul\")\napp.register_blueprint(blueprint)\n</code></pre> <p>When the Beckett flask server is running, this will autogenerate the following TypeScript interface:</p> js/api/types.ts<pre><code>/*\nTHIS FILE IS AUTO-GENERATED, DO NOT ALTER MANUALLY.\n*/\n// prettier-ignore\nexport interface PeopleGetPeopleResponse {\n\"__type__\": string\n\"__http_status_code__\": number\n\"name\": string\n}\n...\n</code></pre> <p>Beckett automatically adds additional parameters to any <code>APIResponse</code> object it such as <code>__type__</code> and <code>__http_status_code__</code>. Beckett's TypeScript API Client uses these fields to introspect the API response and handle errors gracefully for you.</p> <p>Under the hood, we use attrs and cattrs to take the types in the classes we define and transform them into their TypeScript equivalents.</p>"},{"location":"features/#react-pages","title":"React pages","text":"<p>Beckett will auto-generate any new React page when you register a new Beckett page in the Flask service, when you are in development mode. Beckett's is built such that a Flask route (defined through the URL of a Flask view function) can be linked directly to a React page on the frontend.</p> src/views/people.py<pre><code>import attrs\nfrom src.app import app\nfrom src.beckett.blueprint import BeckettBlueprint\nfrom src.beckett.types import PageProps\nbeckett = BeckettBlueprint(\"people\", __name__, url_prefix=\"/people\")\n# Hiding other endpoints for clarity\n...\nclass ExamplePageProps(PageProps):\nhello: str\n@beckett.route(\"/\")\n@beckett.page()\ndef example_page() -&gt; ExamplePageProps:\nreturn ExamplePageProps(hello=\"world\")\napp.register_blueprint(beckett)\n</code></pre> <p>When the Beckett Flask server is running in development mode it will recognise a new endpoint has been registered, and it makes a new React page linked to the Flask view. This is all handled by applying the <code>@beckett.page()</code> decorator.</p> <p>The generated page will start something like this:</p> src/js/template/people/example_page.tsx<pre><code>import React from 'react'\nimport PageProps from './example_page.type'\nimport {Container, Row} from 'react-bootstrap'\nconst Page: React.FunctionComponent&lt;PageProps&gt; = (props) =&gt; {\nreturn (\n&lt;Container&gt;\n&lt;Row className=\"mb-4 border-bottom\"&gt;\n&lt;h1&gt;Hello, React!&lt;/h1&gt;\n&lt;p&gt;\nhere are my props: &lt;code&gt;{props}&lt;/code&gt;\n&lt;/p&gt;\n&lt;/Row&gt;\n&lt;/Container&gt;\n)\n}\nexport default Page\n</code></pre> <p>The template can be customised by setting the <code>BECKETT_REACT_PAGE_TEMPLATE</code> environment variable to a path.</p> <p>Once this has been generated you are free to go and develop the frontend using any React library you want.</p>"},{"location":"features/#props-for-react-pages","title":"Props for React pages","text":"<p>As well as the base page, <code>beckett.page()</code> also generates a <code>PageProps</code> interface. The response returned by the Flask view are injected as props into this page for you automatically. The generated file for the example above looks something like this:</p> src/js/template/people/example_page.type.ts<pre><code>// This file is generated by @beckett.page()\n// prettier-ignore\nexport default interface PageProps {\n\"hello\": string\n}\n</code></pre> <p>This file will update automatically as you make changes to the Flask view response class and the server is in development mode.</p>"},{"location":"features/#api-client","title":"API Client","text":"<p>TODO</p>"},{"location":"features/#refresh-api-queries","title":"Refresh API queries","text":"<p>TODO</p>"},{"location":"features/#run-it-all-together-at-once","title":"Run it all together at once","text":"<p>Instead of maintaining multiple terminals running two different servers, Beckett provides a single development command to run both the Flask service and React server in development mode. Both are these run in \"hot reload\" - any code changes will restart each server so changes happen immediately.</p> <pre><code>make dev\n</code></pre>"},{"location":"install/","title":"\ud83c\udfd7\ufe0f Install","text":""},{"location":"install/#early-days","title":"Early days","text":"<p>Currently the project is still being set up, but you can use it by forking the project and running the following commands:</p> <pre><code>make build\nmake dev\n</code></pre> <p>This will install everything you need and start the development server.</p>"},{"location":"types_conversion/","title":"\ud83c\udfb9 Types conversion","text":"<p>Remember! Beckett doesn't just convert one way.</p> <p>API requests going into the Beckett Flask service will be checked for type consistency.</p> <p>Beckett Framework uses Beckett types to manage types translation.</p>"},{"location":"types_conversion/#conversion-chart","title":"Conversion chart","text":"<p>We translate Python TypeHints into these TypeScript types, and vice versa:</p> Python TypeScript <code>str</code> <code>string</code> <code>int</code> <code>number</code> <code>float</code> <code>number</code> <code>decimal.Decimal</code> <code>number</code> <code>dict</code> <code>Record&lt;string, any&gt;</code>"},{"location":"types_conversion/#nested-types","title":"Nested types","text":"<p>Nested model classes are converted infinitely:</p> example.py<pre><code>class Subclass:\nhello: str\nclass ExamplePageProps:\ntest: Subclass\n</code></pre> <p>Which generates:</p> types.ts<pre><code>// prettier-ignore\nexport interface Subclass {\n\"hello\": string\n}\n// prettier-ignore\nexport default interface PageProps {\n\"test\": Subclass\n}\n</code></pre>"}]}